.. role:: raw-html-m2r(raw)
   :format: html


01.语法规则
===================

1.参考资料
-----------------


* 
  `github例程 <https://github.com/ttroy50/cmake-examples>`_

* 
  `定义和术语 <https://cmake.org/cmake/help/latest/manual/cmake-language.7.html>`_

* `官网 <https://cmake.org/cmake/help/latest/index.html>`_

2.语法
---------


#. 指令大小写无关（如 ``add_library`` 等价于 ``ADD_LIBRARY``）
#. 参数和变量、OPTION大小写敏感（如REQUIRED不能写成required）


3.常用函数/宏
--------------------------------------

变量设置和引用
~~~~~~~~~~~~~~

.. code-block:: cmake

   set(SOURCES
       src/Hello.cpp
       src/main.cpp
   )
   message(${SOURCES})   # src/Hello.cppsrc/main.cpp
   set(env{变量名} 值)    # 获取环境变量 
   message($env{HOME})   # 使用环境变量
   
.. hint:: 

  #. 单个variable有多个arguments时，用分号将argument进行concatenate后再进行赋值
  #. 然而message显示时，不会出现分号
  #. 使用一个变量时，不同于 ``bash`` 可以不加上{}，在 ``CMakelists`` 中一定要加上


生成库
~~~~~~

.. code-block:: cmake

   add_library(target_name STATIC 文件名)     # 静态库
   add_library(target_name SHARED 文件名)     # 动态库


* 构建的 ``library`` 可以不写全名字，如只写hello，cmake会自动补全为\ ``libhello.so``\ 或\ ``libhello.a``

生成可执行文件
~~~~~~~~~~~~~~

.. code-block:: cmake

   add_executable(target_name 文件名)

添加头文件搜索路径
~~~~~~~~~~~~~~~~~~

只有添加路径的，没有直接添加头文件绝对路径的

方法一：

.. code-block:: cmake

   # 当前包的头文件目录要放在前面
   include_directories(
    include  # 相对于当前CMakeLists所在的文件目录
    ${catkin_INCLUDE_DIRS}
   )


* 控制追加的路径是放在原来的前面还是后面（设置参数 ON）

.. code-block:: cmake

   set(cmake_include_directorirs_before ON)
   set(cmake_include_directorirs_after ON)


.. hint:: 

   ``#include <file.h>``\ 时对应的位置是相对于\ ``include_directories``\ 中导入的路径
   例如：\ ``include_directories``\ 的路径是/include/；头文件在/include/package_name/header.h则最终的编写应为\ ``#include <package_name/header.h>``

方法二：

.. code-block:: cmake

   target_include_directories（target_name
       PUBLIC
           头文件目录）


* 方法二的头文件路径仅适用特定的\ ``target``\ ，方法一的适用于所有\ ``target``

添加额外的库搜索路径
~~~~~~~~~~~~~~~~~~~~

.. code-block:: cmake

   link_directories(dir_path)

链接可执行文件与库
~~~~~~~~~~~~~~~~~~

.. code-block:: cmake

   target_link_libraries(target_name library_name)


* `有关关键词option： private、public、target 的区别 <[https://leimao.github.io/blog/CMake-Public-Private-Interface/](https://leimao.github.io/blog/CMake-Public-Private-Interface/>`_\ )：

本质是用于描述一个链接是否能被继承

- ``private``\ (default)：目标文件A所链接过的库不会被目标文件B 继承
- ``public``\ ：目标文件A所链接过的库可被目标文件B 继承
- ``interface``\ ：目标文件A所链接过的库不可被目标文件B继承，但是目标文件C链接B时可链接到目标文件A的链接库

有如下案例：比如给定三个文件，分别为可执行文件A\ ``eat_apple``\ ；库A\ ``fruit`` (有size和color两个函数)；库B\ ``apple_libraries``\ (有apple_size这个函数，该实现依赖\ ``fruit库``\ 调用了size函数)  。如果，在实现库B到库A的link时，采用private关键词；eat_apple中调用了apple_size这个函数，依赖了apple_libraries库。此时可执行文件A到库B的link无论使用哪种关键词，都会有link错误。因为前面采用了private关键词，库A到库B的link不会被可执行文件A继承。需要将库B到库A的private link改为public link才行。

:raw-html-m2r:`<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/GVwiCAlL2biYLEkP.png!thumbnail" alt="img" style="zoom:67%;" />`

`修改target属性 <https://cmake.org/cmake/help/v3.18/manual/cmake-properties.7.html#target-properties>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cmake

   set_target_properties(target1 target2 ...
                         PROPERTIES prop1 value1
                         prop2 value2 ...)

* 修改文件生成名前/后缀

.. code-block:: cmake

   set_target_properties(lib_cpp PROPERTIES PREFIX "")               #  指定前缀
   set_target_properties(lib_cpp PROPERTIES OUTPUT_NAME "lib_cpp")   #  指定文件名
   set_target_properties(lib_cpp PROPERTIES SUFFIX ".so")            #  指定后缀

原来默认生成\ ``lib_cpp.cpython-37m-x86_64-linux-gnu.so``\ 现在是\ ``lib_cpp.so``\ ；更多属性配置可参考\ `link <https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#target-properties>`_

`指明链接依赖 <https://cmake.org/cmake/help/latest/command/add_dependencies.html>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 指明在target生成前，需要先生成某些\ ``target``

.. code-block:: cmake

   add_dependencies(<target> [<target-dependency>]...)


`给target添加编译选项 <https://cmake.org/cmake/help/latest/command/target_compile_options.html?highlight=target_compile_options>`_ 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cmake
   
   # e.g.
   target_compile_options(target_name PUBLIC "-g")

.. attention:: 
   会覆盖 ``CMAKE_BUILD_TYPE``



`find_package <https://cmake.org/cmake/help/v3.18/command/find_package.html?highlight=find_package>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: plain

   find_package(<PackageName> [version] [EXACT] [QUIET] [MODULE]
                [REQUIRED] [[COMPONENTS] [components...]]
                [OPTIONAL_COMPONENTS components...]
                [NAMES name1 [name2 ...]]  
                # If the NAMES option is given the names following it are used instead of <PackageName>
                [NO_POLICY_SCOPE])


* 指定路径

.. code-block:: cmake

   find_package(PCL REQUIRED 
   PATHS  库路径
   NO_DEFAULT_PATH)  # 只在PATHS路径下寻找，不使用默认的搜索路径


* 
  ``find_package``\ 宏执行后会产生相关的变量，例如，\ ``<package_name>_INCLUDE_DIRS`` or\ ``<package_name>_INCLUDES`` or ``<package_name>_INCLUDE_DIR``\ 具体看相关模块的设计

* 
  cmake modules 指文件\ ``FindXXX.cmake``\ ，要指定 cmake module的搜索路径，可以配置如下参数；不过它也有默认的搜索路径即cmake安装路径下的Module目录（e.g. /usr/share/cmake-3.16/Modules），在默认路径下没找到，才去CMAKE_MODULE_PATH下找

.. code-block:: cmake

   set(CMAKE_MODULE_PATH 路径名)
   # set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "/usr/share/cmake/geographiclib/")

* ``find_packaege``\ 还有一种\ ``Config Mode``\ ，当没找到\ ``FindXXX.cmake``\ 时将按特定的规则进行搜寻，具体可参考\ `英文文档 <https://cmake.org/cmake/help/latest/command/find_package.html#search-procedure>`_\ 和\ `中文说明 <https://zhuanlan.zhihu.com/p/50829542>`_\ （PATH环境变量也会起作用），
* 该种模式下找的是\ ``...LibConfig.cmake``\ 或\ ``...lib_config.cmake``\ 。可添加的搜索路径为

.. code-block:: plain

   <package>_DIR
   CMAKE_PREFIX_PATH
   CMAKE_FRAMEWORK_PATH
   CMAKE_APPBUNDLE_PATH
   PATH


* ``find_package``\ 中如果find的包是\ ``catkin``\ ，则\ ``components``\ 用于将\ ``components``\ 涉及的包的环境变量都统一到\ ``catkin_ prefix``\ 的环境变量中。\ `用与节省敲代码的时间(typing time) <http://wiki.ros.org/catkin/CMakeLists.txt#Why_Are_Catkin_Packages_Specified_as_Components.3F>`_

`打印信息 <https://cmake.org/cmake/help/latest/command/message.html>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cmake

   message(STATUS|WARNING|FATAL|SEND_ERROR ${})# 这种形式一定要加STATUS这些option
   message("...")


catkin_package (ros)
~~~~~~~~~~~~~~~~~~~~~~~


* `官方文档 wiki <http://wiki.ros.org/catkin/CMakeLists.txt#catkin_package.28.29>`_\ 、\ `官方文档 api <https://docs.ros.org/en/groovy/api/catkin/html/dev_guide/generated_cmake_api.html#catkin_package>`_
* 作用：安装\ ``package.xml``\ ；生成可被其他package调用的配置文件(即.config或.cmake文件)。使其他包\ ``find_package``\ 时可以获取这个包的相关信息，如依赖的头文件、库、CMake变量

.. code-block:: cmake

   catkin_package(
     INCLUDE_DIRS include
     CATKIN_DEPENDS cloud_msgs
     DEPENDS PCL
   )
   add_executable(imageProjection src/imageProjection.cpp)
   add_executable(featureAssociation src/featureAssociation.cpp)
   add_executable(mapOptmization src/mapOptmization.cpp)
   add_executable(transformFusion src/transformFusion.cpp)


* 
  实测其并不会将当前的include等文件夹拷贝到devel目录中

* 
  必须要在声明targets前（即使用add_library()或add_executable().前） 调用该宏

`option <https://cmake.org/cmake/help/v3.20/command/option.html>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cmake

   option(<variable> "<help_text>" [value])

安装
~~~~


* 
  可以安装的内容：编译产生的target文件（即可执行文件、库文件）；其他文件

* 
  若要指定安装路径：

方法一：命令行

.. code-block:: bash

   $ cmake .. -DCMAKE_INSTALL_PREFIX=/install/location

方法二：cmake-gui等图形界面进行
:raw-html-m2r:`<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/fCeDn3uR7Aeffvas.png!thumbnail" alt="img" style="zoom:67%;" />`


* 指定安装的内容和相对路径：
  安装可执行文件，并安装到到指定目录：\ ``${CMAKE_INSTALL_PREFIX}/bin``

.. code-block:: cmake

   install (TARGETS <target_name>
       DESTINATION bin)

​       安装库文件，并安装到指定目录：\ ``${CMAKE_INSTALL_PREFIX}/lib``

.. code-block:: cmake

   install (TARGETS <target_name>
       LIBRARY DESTINATION lib)

​       安装头文件（即把整个目录拷贝过去）

.. code-block:: cmake

   install(DIRECTORY ${PROJECT_SOURCE_DIR}/include/
       DESTINATION include)

​       安装配置文件，拷贝到\ ``${CMAKE_INSTALL_PREFIX}/etc``

.. code-block:: cmake

   install (FILES <file_name>
       DESTINATION etc)


* ``make install``\ 后 CMake 会生成 install_manifest.txt文件（含安装的文件路径，到时可基于这个文件删除安装文件）

.. code-block:: cmake

   e.g.
   /usr/local/include/ceres/autodiff_cost_function.h
   /usr/local/include/ceres/autodiff_first_order_function.h
   /usr/local/include/ceres/autodiff_local_parameterization.h


.. hint:: 
   默认安装路径：/usr/local/include; /usr/local/bin; /usr/local/lib/cmake


导入额外的CMAKE代码
~~~~~~~~~~~~~~~~~~~


* 方法一：

.. code-block:: cmake

   include(<file|module> [OPTIONAL] [RESULT_VARIABLE <var>]
                         [NO_POLICY_SCOPE])

从某个文件(CMakeLists.txt)或模块(.cmake)中导入cmake代码；未指定地址时，将在\ **CMAKE_MODULE_PATH**\ 中寻找

.. code-block:: cmake

   set(VTK_CMAKE_DIR "${VTK_SOURCE_DIR}/CMake")
   set(CMAKE_MODULE_PATH ${VTK_CMAKE_DIR} ${CMAKE_MODULE_PATH})
   include(vtkCompilerChecks)  # /VTK-8.2.0/CMake/vtkCompilerChecks.cmake


* 方法二：导入CMakeLists.txt，source_dir对应CMakeLists.txt的所在目录

.. code-block:: cmake

   add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])

`执行命令行 <https://blog.csdn.net/qq_28584889/article/details/97758450>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cmake

   # 相关待执行的命令； 存储标准输出的变量
   execute_process(COMMAND python -c "from sysconfig import get_paths;print(get_paths()['include'])" OUTPUT_VARIABLE DUMMY)

4.案例分析
----------

Alias target
~~~~~~~~~~~~~~~~~~~

* ``target``，根据上下文，应该指的是\ ``library``\ 这种target，而不是executable file；且是\ ``alias target``；采用 ``taget-based`` 的方法可以不用再 ``include_directory``，只需要\ ``target_link_libraries``\ 就能完成编译（\ `link <https://github.com/ttroy50/cmake-examples/tree/master/01-basic/H-third-party-library>`_\ ）
* 案例1：

:raw-html-m2r:`<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/wbtoJSQAxXyl23X8.png!thumbnail" alt="img" style="zoom: 50%;" />`

等价于

:raw-html-m2r:`<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/X74TytKWlvFw0Xst.png!thumbnail" alt="img" style="zoom:50%;" />`


* 案例2（\ `link <https://github.com/fzi-forschungszentrum-informatik/Lanelet2/issues/39>`_\ ）

:raw-html-m2r:`<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/srnzrPDtnm75OZuv.png!thumbnail" alt="img" style="zoom:67%;" />`


* target-based的target（library）采用的是alias targets，其生成可参考（\ `link <http://www.smartredirect.de/redir/clickGate.php?u=IgKHHLBT&m=1&p=8vZ5ugFkSx&t=vHbSdnLT&st=&s=&url=https%3A%2F%2Fgithub.com%2Fttroy50%2Fcmake-examples%2Fblob%2Fmaster%2F01-basic%2FD-shared-library%2FREADME.adoc&r=https%3A%2F%2Fshimo.im%2Fdocs%2FgjWXYXXprqjtDDgk>`_\ ）

:raw-html-m2r:`<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/uK5A6MiUUP6Ylf96.png!thumbnail" alt="img" style="zoom:50%;" />`


5.DEBUG
-----------

No CMAKE_CXX_COMPILER could be find
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: bash

   $ sudo apt install build-essential


未定义的引用（undefined reference）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一般来说有两种情况。一种是没下载相关的库；一种是库的冲突，比如ros的opencv库与从源码编译安装到系统的opencv库发生冲突，至依赖被覆盖而使目标文件无法成功链接到库。可卸载安装到系统的opencv库（如用sudo make uninstall来卸载）；一种是已下载但没找到，


imported target "..." references the file   "..." but this file does not exist.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`locate 定位相关位置后，使用软链接 <https://blog.csdn.net/weixin_45617478/article/details/104513572>`_


no such file or directory：没有找到头文件的路径，导入头文件失败。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
在已有头文件的情况下，可直接添加绝对路径进行搜索；\ `或者头文件名不对，进行修改即可 <https://github.com/RobustFieldAutonomyLab/LeGO-LOAM/issues/219>`_

.. code-block:: cmake

   # e.g. include/utility.h:13:10: fatal error: opencv2/cv.h: No such file or directory #include <opencv2/cv.h>
   include_directories(
      include
      绝对路径   # e.g. /home/helios/include
   )

6.IDE插件
----------
- clion插件： ``Cmake simple highlighter``
- vscode: ``cmake-format`` (需先pip3 install cmake_format)（格式化）

7.