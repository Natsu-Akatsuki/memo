# 02. 编译模型

## c++程序构建过程

* `预处理器` 将.c/.cpp源代码进行 `预处理` (preprocess)得到.i文件；预处理包括宏替换、导入头文件、去除注释等行为
* `编译器` 对.i源文件进行 `编译操作` (compile)得到含汇编指令的.s汇编代码(assemble code)；该**步骤会进行语法检查**，而**不会发现逻辑错误**；汇编代码可用vim打开

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210917222609207.png" alt="image-20210917222609207" style="zoom:67%; " />

* `汇编器` 对.s文件进一步 `汇编操作` (assemble)得到.o 二进制目标(object)文件
* `链接器` 对.o文件进行 `链接` (link)得到可执行文件

对应的的命令行(e.g. gcc):

```bash
$ gcc -E <>.c -o <>.i
$ gcc -S <>.i -o <>.s
$ gcc -c <>.s -o <>.o
$ gcc <>.o -o <> # 无参数
# 一步到位
$ gcc -o <output_file_name> <input_file_name>
```

.. note:: 符号未定义、符号重定义 ` ` duplicate symbol ` ` 是链接时期的错误

其他常用编译选项：

```bash
-I：指定头文件目录 （e.g. -I.. -I ..可加空格也可不加空格，可相对路径）
-O：是否进行优化（0<1<2<3，其中0为不优化；1为default优化等级；3为最高级别的优化）
-D：指定宏（e.g. -D DEBUG，等效于程序里面的 #define DEBUG)
-L: 指定库目录搜素路径
-Wall：是否输出警告信息
-g：在生成的代码中添加调试信息，配合gdb调试工具使用
-std：设置c++标准（e.g. -std=c++14）
-fPIC: Position-Independent Code
-rpath: 将动态库路径写到可执行文件中(hard code)，会hide LD_LIBRARY_PATH的效果
```

## 动态库查询

```bash
# 查看一个target文件运行时需要链接的动态库
$ ldd <file>
# 查看一个正在运行的进程所链接的动态库
$ pldd <pid>
```

![image-20210916224735535](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210916224735535.png)

## 实战

### [precompile source file的#号是什么？](https://stackoverflow.com/questions/25137743/where-do-we-use-i-files-and-how-do-we-generate-them)

一种特殊的注释

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20211002140045353.png" alt="image-20211002140045353" style="zoom:67%; " />
