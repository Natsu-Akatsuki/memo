# 术语与语法规则

Someone who is sophomoric about concepts and reasoning may try things randomly, and wastes a lot of time.

## [类型](https://en.cppreference.com/w/c/language/type)

类型是函数(function)、表达式(expression)、对象(object)的属性；类型决定了**二进制值的转译方式**（这些二进制值存储在对象中或者是表达式求值的结果）

```c++
#include <iostream>

int main() {
  // 二进制1100001的int型表示为  ->  97
  // 二进制1100001的char型表示为 ->  'a'
  using namespace std; 
  int int_num = 97; 
  char char_num = int_num; 
  cout << "int_num: " << int_num << endl; 
  cout << "char_num: " << char_num << endl; 
}

```

### 类型别名

用简短的类型别名替换完整的、较长的类型名

``` c++
// 语法一
typedef src_type alias_type
// 语法二
using alias_type = src_type（from c++11）
```

.. note:: 一般来说，推荐使用 `using` 这种语法，因为在标识数组类型时， `using` 会更直观（如下例所示）；另外[typedef不支持模板类别名](https://www.cnblogs.com/yutongqing/p/6794652.html)

``` c++
int arr[4]; 
typedef int IntArr[4]; // [4]需要写在后面
using IntArr = int[4]; 

```

### size_t

`size_t`类型是一个特殊的类型别名；是[sizeof](https://en.cppreference.com/w/c/language/sizeof)函数返回对象的类型(size type)，是一个无符号的整型，它的大小是由操作系统所决定的；
在实现动态分配内存时很有用。

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210728200535276.png" alt="img" style="zoom:67%;" />

.. attention:: 标准库中的operator\[\]也涉及`size_t`，所以遍历时用unsigned或者int去访问可能会出错
<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210728200948093.png" alt="img" style="zoom: 50%;" />

### incomplete type

> .... has initializer but incomplete type

[incomplete type](https://en.cppreference.com/w/c/language/type)：这种类型的对象，编译器是不知道它的大小的，如int[]

### 引用

- const左值引用和右值引用能够延展临时变量的生存期

``` c++
#include <iostream>
using namespace std;

int main() {
   double tc = 21.5;
   /*
   * 以下近似于：创建一个临时变量，然后对其进行绑定
   * double temp = 7.07;
   * const double &rd1 = temp;
   * 在语法上只有const左值引用才能绑定临时变量，否则有如下报错：
   * “non-const lvalue reference to double can not bind a temporary of type double”
   */
   const double &rd1 = 7.07;

   // 通过const左值引用或右值引用对临时变量起别名，临时变量的lifetime会被extend
   double &&rd2 = 7.07;
   rd2 = 33;
}
```

.. note:: const左值引用，不能修改该临时变量（或称不具名变量/匿名变量）；右值引用，才可以修改该临时变量

### 类型转换

- 操作符对操作数会有要求，或操作数满足某种特定的类型，或操作数都需要同样的类型；如果不满足相应的需要，就会出现类型转换
- [隐式类型转换](https://en.cppreference.com/w/cpp/language/implicit_conversion)

#### [C风格类型转换](https://en.cppreference.com/w/cpp/language/explicit_cast)

c风格的显式类型转换包含了一系列的转换操作（也就是它会尝试一组转换操作，例如首先进行const_cast，然后进行static_cast等...）；c++中一般都使用细颗粒度的，更具体的c++风格的类型转换操作（即static_cast, const_cast, reinterpret_cast...等）

![image-20210930163600592](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210930163600592.png)

### 数组

- c++没有引用的数组。因为数组的元素应该是对象而引用不是对象。

### 类型退化

- 数组到指针(array to pointer)的隐式转换

```c++
int a[3]; 
// 该指针指向数组的首元素
auto b = a; // b->int* 而不是 int*[3]
```

![image-20210815211847957](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210815211847957.png)

## 类

### 构造函数

- 创建一个类时编译器至少给一个类添加如下特殊的函数， `默认构造函数`（函数体为空，无参）； `默认拷贝函数` ，对属性进行值拷贝（浅拷贝）；赋值运算符(assignment operator)，对属性进行值拷贝

- 构造函数不具名，只有在初始化时才能被调用。构造函数有多种，有（类型）转移构造函数（convert constructor 不带explicit specifier）；调用时没有实参，则调用默认构造函数；实参是同类型的对象时，调用的构造函数为拷贝构造函数和移动构造函数

![img](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/TUuFl421J2PPxDeO.png!thumbnail)

### [构造函数的调用规则](https://www.bilibili.com/video/BV1et411b73Z?p=109)

- 如果定义了有参构造函数，编译器不会提供默认无参构造函数，但会提供默认拷贝构造函数
- 如果定义了拷贝构造函数，则编译器不会提供其他构造函数

.. hint:: 至少会有一个拷贝构造函数

### [带初始化列表的构造函数](https://en.cppreference.com/w/cpp/language/constructor)

```c++
// constructor definition
ClassName([param-list]) <function-body[member-initializers-list]/brace-init-list>
```

.. note:: expression-list属于函数定义的函数体部分

```bash
struct S {
    int n;
    S(int); // constructor declaration
    S() : n(7) {} // constructor definition.
                  // ": n(7)" is the initializer list
                  // ": n(7) {}" is the function body
};
S::S(int x) : n{x} {} // constructor definition. ": n{x}" is the initializer list
int main()
{
    S s; // calls S::S()
    S s2(10); // calls S::S(int)
}
```

### [this指针](https://www.bilibili.com/video/BV1et411b73Z?p=115&spm_id_from=pageDriver)

- this指针（类似于python中的self）是一个隐含于每一个非静态成员函数（实例方法）中的特殊指针，它指向调用该成员函数的那个对象；对一个对象调用其成员函数时，编译器先将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式地使用this指针
- this指针不是一个常规的变量，而是一个右值，不能取地址即 `&this`
- 涉及this指针的场景：
  - 解决名称冲突：区分同名的方法形参和属性
  - 返回对象本身（ `return *this` ）（用于链式编程）

### 多继承

```c++
class <派生类名>: <继承方式1><基类名1>, <继承方式2><基类名2>, …
{

 <派生类类体>

}; 
```

### [对象模型](https://www.bilibili.com/video/BV1et411b73Z?p=114)

- 方法和属性是分开存储的；只有实例属性是存放在对象上的
- 空类的大小(sizeof)为1，是为了保证每个（空）对象都有独一无二的内存地址，以使编译器区分他们

## 内存

### 动态内存分配：智能指针

引入智能指针是为了更好地管理指针和管理动态内存空间。以前管理动态内存是通过`new` 来分配内存空间，通过 `delete` 来释放内存空间。但容易发生一种情况，用 new 在分配了内存空间，但是忘了使用 delete释放内存空间，或者由于异常的抛出，程序无法调delete，这就会造成内存的泄露（该释放的内存空间没有被释放）。于是就有人提出能不能有一种指针，在它销毁的时候，它所指向的对象也会被销毁，于是就引入了智能指针类，它包含了一个满足这种一并销毁需求的析构函数。

.. hint:: 存在一种情况，一个对象由多个指针管理，那就可能会导致多次的释放，于是就引入了包含引用计数技术的共享指针 `shared_ptr`（每有一个共享指针，引用计数+1），只有引用计数为0时，指向的对象才会释放

.. hint:: 有的时候希望只能有一个智能指针管理对象，那就可以使用 `unique_ptr`

### 语法规则

``` c++
/*
* 用法：
* 1.导入<memory>头文件
* 2.构造（两种方法：单纯用share_ptr；调用make_shared）   
*/
#include <memory>
int main() {
   // 管理动态内存，创建的智能指针的形参为相应的地址
   std::shared_ptr<int> foo = std::make_shared<int> (10);
   // same as:
   std::shared_ptr<int> foo2 (new int(10));

   auto bar = std::make_shared<int> (20);
   auto baz = std::make_shared<std::pair<int,int>> (30,40);

   std::cout << "*foo: " << *foo << '\n';
   std::cout << "*bar: " << *bar << '\n';
   std::cout << "*baz: " << baz->first << ' ' << baz->second << '\n';
   return 0;
}
```

### 动态内存分配：new/delete

![img](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210805103706659.png)

``` c++
auto ptr = new int (6); 
auto ptr = new (int) {6};

// 构造数组
int *arr = new int[10];
// 构造数组，数据默认初始化为0
int *arr = new int[10]();
```

## 函数

### 内联函数

内联函数是为了减少函数调用的开销（编译器处理内联函数时相当于将函数的调用，替换为内联函数的函数体）；相当于宏，但比宏多了类型检查，真正具有函数特性；编译器一般不对包含循环、递归、switch等复杂操作的函数进行内联；在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数；

``` c++
// 声明1（可加可不加inline，推荐加inline）
inline int functionName(int first, int second,...);
// 声明2
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {
   ; // todo      
}

// 类内定义，隐式内联
class A {
   int doA() { return 0; }
}

// 类外定义，需要显式内联
class A {
   int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```

.. attention:: 实例的内联函数语法需要类内声明，类外定义

### [auto形参(c++20)](https://en.cppreference.com/w/cpp/language/auto)

![image-20210929184924216](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210929184924216.png)

```c++
template <typename T>
void print_container(T set) {
  for (auto &element : set) {
    cout << element << " ";
  }
  cout << endl;
}

// 等价
void print_container(auto set) {
  for (auto &element : set) {
    cout << element << " ";
  }
  cout << endl;
}
```

## [属性(attribute)](https://en.cppreference.com/w/cpp/language/attributes)

**使用场合**

想在编译时告知开发者某个函数即将deprecated，则使用 `deprecated` 属性（当程序中调用这个函数时，编译期时则会弹出相关的信息）

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210811202856933.png" alt="img" style="zoom: 80%; " />

## [操作符(operator)](https://en.cppreference.com/w/cpp/language/operator_precedence)

### 运算符优先级

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210924234049109.png" alt="image-20210924234049109" style="zoom: 80%; " />

### 加法操作符

- 一元加法操作符能触发整型提升(integral promotion)

![img](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/aVEipBB1RGJa00DO.png!thumbnail)

### 逻辑和关系操作符

其操作数和结果均为右值（结果的类型为bool）

### 自增自减表达式

- 后缀表达式（i++）的优先级高于前缀表达式(++i)
- 后缀表达式的取值(evaluation)为 `右值` （返回是操作数的拷贝/临时变量）；前缀表达式的取值为`左值`（在原来的值的基础上+1）

- 一般推荐使用**前缀表达式**，避免拷贝的开销；但现在一些编译器已经能够对后缀表达式进行优化，使其不用构建临时变量

> Post-increment and post-decrement creates a copy of the object, increments or decrements the value of the object and returns the copy from before the increment or decrement.

``` c++
int main() {
   int arr[] = {1, 2, 3}; 
   auto ptr = arr; 
   cout << *ptr << endl; // 1
   cout << *ptr++ << endl; // 1 后缀表达式的evaluation为原值的copy；此处等价于*(ptr++)->*ptr
   cout << *++ptr << endl; // 3 后缀表达式处理完后，地址已+1，此处地址再+1；此处等价于*(++ptr)
}

```

### 逗号操作符表达式

虽然左操作数也要进行取值(evaluate)，但逗号操作符表达式的取值(evaluation)只跟第二个操作数的取值有关（它们的type, value, value category将保持一致）

![image-20210925000412285](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210925000412285.png)

### 域解析运算符

- 全局作用域符(::name)：用于类、类成员、成员函数、变量前，表示作用域为**全局命名空间**
- 类作用域符(class::name)：用于表示指定类型的作用域范围是具体某个类的
- 命名空间作用域符(namespace::name)：用于表示指定类型的作用域范围是具体某个命名空间的

### [操作符重载(operator overload)](https://en.cppreference.com/w/cpp/language/operators)

**应用场景**

拓展操作符的功能，使其操作数不仅支持内建类型还支持自定义类型。

---

- 操作符支持两种方式的重载，操作符作为成员函数的重载`(objectA).operator+(objectB)`和操作符作为全局函数的重载`operator+(pA+pB)`；对于输入输出流的操作符，不能作为成员函数进行重载，因为操作符的左操作数应该为输入/输出流对象

- 操作符的语法等价性

    ``` plain
    custom_object.operator<<(cout) 等价于 custom_object << cout;
    operator<<(cout,custom_object) 等价于 cout << p;
    ```

### specifier

[override](https://en.cppreference.com/w/cpp/language/override)：显式告诉编译器这个函数是需要重写的虚函数

```c++
[Semantic Issue]
only virtual member functions can be marked override 
'void B::bar()' marked 'override', but does not override   
```

constexpr：告诉编译器，这个**函数或变量**的值可以出现在const expression中

## [初始化](https://en.cppreference.com/w/cpp/language/initialization)

- 初始化即在变量构造时提供初值；函数调用和函数返回时也存在初始化；

- 初始化器(initializer)有三种： {exp list} 花括号，圆括号 (initializer list) ，等号  = exp

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210927194119218.png" alt="image-20210927194119218" style="zoom:67%;" />

---

**NOTE**

- expression-list: comma-separated list

- 数组不支持expression-list的形式(array initializer must be an initializer-list)

---

## 宏

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210803143453257.png" alt="img" style="zoom:67%;" />

### [pragma once](https://en.wikipedia.org/wiki/Pragma_once)

`#pragma`和`#ifdef`/`#ifndef`/`#endif`一样都是preposess directive（预处理指令），前者是编译器特性（部分版本较老的编译器不支持），后者是c++标准（所有编译器都支持该语法）；都能保证一个头文件不会被重复包含(include)。前者的作用单位是一个文件，后者的作用单位是代码块。前者对于某些编译器能够提高编译速度；后者需要避免有重复的宏名。

## 语法糖

### range-based loop

又称为range-for，是for循环的语法糖，用于遍历序列容器、字符串和内置数组

### [匿名表达式(Lambda expressions)](https://en.cppreference.com/w/cpp/language/lambda)

一般构建可调用对象(callable object)可以通过对类的`()`操作符(operator)进行重载来构建，但自己写起来比较长，所以有了lambda表达式这种简化和灵活的写法。匿名表达式可以认为是一种语法特性，该表达式会被**编译器翻译为类进行处理**；能够用来生成一个**可调用对象**（该对象的类型是一个**类**）/[又或者说构建一个不具名的函数对象，同时该对象能够使用（捕获capture）该函数对象所在域的变量（这样的对象又称为：closure）](https://en.cppreference.com/w/cpp/language/lambda)

![image-20210821210326787](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210821210326787.png)

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210821223323813.png" alt="image-20210821223323813"  />

- 有关捕获，个人理解是描述了可以在`function body`使用的外部变量，具体来说即构建的函数对象所在域的变量

![image-20210821223919209](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210821223919209.png)

### [structured binding](https://en.cppreference.com/w/cpp/language/structured_binding)

为**c++17**的特性，所用类似python的解包；structured binding是一个已存在对象的别名(alias)，类似引用，但又有区别

## 编译期处理

### constexpr

constexpr可修饰函数和变量，满足一定条件的才能成为`constexpr variable`, `constexpr function`，可按照[cpp reference](https://en.cppreference.com/w/cpp/language/constexpr)核准

## 术语

### [字面值(literals)](https://www.tutorialspoint.com/cplusplus/cpp_constants_literals.htm)

字面值示例：

```c++
// integer literal
211...
// string literal
"hello world"...
// boolean literal    
true
false
// character literal
'a'...
// the pointer literal
nullptr
// the user-defined literal    
...
// floating point literal    
```

.. attention:: 注意 ``literals`` 和 ``literal type`` 是不一样的

### 声明(declaration)和定义(definition)

- 声明：一般的声明即给程序引入(introduce)或重引入(re-introduce)一个实体的名称(name)，以便让程序可以根据这个名称来使用实体；普通的声明不会对应一段具体的汇编代码
- 定义：在上面声明的基础上（i.e.定义是一种特殊的声明），还会为这个实体开辟存储空间(storage)

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/venn_declaration.png" alt="img" style="zoom: 50%;" />

---

**NOTE**

一个声明形如：
decl-specifier-seq  init-declartor-list

其中：

**decl-specifer-seq**: a sequence of whitspace-separated specifiers

**init-declarator-list**: a sequence of init-declarators

**init-declarators**: declarator initializer

---

### 容器适配器(container adapter)

修改一个 **底层序列容器**，使其表现出新的功能和接口，比如[stack](https://en.cppreference.com/w/cpp/container/stack) 使`deque` 表现出了后进先出的栈功能

- 容器适配器有 `stack`, `queue`,[priority_queue](https://en.cppreference.com/w/cpp/container/priority_queue)

```c++
#include <deque> 
#include <iostream> 
#include <list> 
#include <stack> 
#include <vector> 
using namespace std;

int main() {
    // stack的构造 
    stack<int> stackA; 
    stack<int, deque<int>> stackB; // deque is the default container 
    stack<int, vector<int>> stackC; 
    stack<int, list<int>> stackD; 
    return 0;
}
```

### 类型适配器(container adapter)

### cv 修饰/限定符(const and volatile qualifier)

#### const qualifier(修饰符)

- 修饰变量，说明该变量是只读的（类似python的不可变对象）
- 修饰指针：常指针，该指针的指向不发生变化

- 修饰引用，指向常量的引用(reference to
    const)。用于修饰形参，既避免了拷贝，又避免函数对值的修改。

- 修饰成员函数，说明在该成员函数内不能修改成员变量（在成员属性声明时加关键词mutable，在常函数中则可以修改）

.. hint:: const修饰成员函数本质上是修饰this指针

``` c++
// 类
class A
{
private:

    const int a;                // 常对象成员，只能在初始化列表赋值

public:

    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值

}; 

void function()
{

    // 对象
    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 指针变量，指向常对象
    const A &q = a;             // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指向常量的指针
    char* const p3 = greeting;          // 常指针（指针的指向不能发生改变）
    const char* const p4 = greeting;    // 指向常量的常指针

}

// 函数
void function1(const int Var); // 形参只读
void function2(const char* Var); // 形参为指针，指向的对象只读
void function3(char* const Var); // 形参为指针，指针为常指针
void function4(const int& Var); // 常量的引用

// 函数返回值
const int function5(); // 返回一个常数
const int* function6(); // 返回一个指针，指针指向常量
int* const function7(); // 返回一个常指针

```

#### 说明符(specifier)

### static specifier

根据不同的对象，表现出不同的作用

1. 修饰普通变量，修改变量的存储区域和生命周期（lifetime），使变量存储在静态区，在main函数运行前就分配了空间
2. 修饰普通函数（描述该函数具有内部链接性），将域拓展到整个文件。在多人开发项目中，为了防止与他人命名空间里的函数重名，可以将函数定位为static
3. 修饰类成员
    - 修饰成员变量（相当于声明类属性）：所有对象能共享同一份数据；在编译阶段分配内存；其是类内声明，类外定义；访问时可通过对象或类名进行访问；也可以有访问权限的(private,
        protected, public)
    - 修饰成员函数（相当于声明类方法）：所有对象共享同一个函数；该方法不能访问实例属性；类内声明，类外定义；访问时可通过对象或类名进行访问；也可以有访问权限(private,
        protected, public)

### 引用

### [dangling reference](https://en.cppreference.com/w/cpp/language/reference)

当引用的对象的lifetime已经结束了，那此时的引用则为 `dangling reference`

``` c++
std::string &f() {
    std::string s = "Example";
    return s; // exits the scope of s:
    // its destructor is called and its storage deallocated
}

int main() {
    std::string &r = f(); // dangling reference
    std::cout << r;       // undefined behavior: reads from a dangling reference
    std::string s = f();  // undefined behavior: copy-initializes from a dangling reference
}
```

.. note:: 报错信息为段错误

### 左值和右值

- 左值和右值都是
`expression` 。根据expression的取值(evaluation)来区别是左值表达式还是右值表达式。

- 泛左值不是亡值就是左值；能取地址（i.e能使用&操作符）的才是泛左值

- 右值可能是亡值，也可能是纯右值

### [内存泄露](https://en.cppreference.com/w/cpp/language/new)

- new返回的指针被释放，导致原来被指向的对象不能通过该指针来访问和不能使用delete来释放

### [标识符(identifier)](https://en.cppreference.com/w/c/language/identifier)

- 标识符是一个任意长度的序列，该序列由下划线、数字和拉丁字母组成
- 可用于描述程序中的如下实体：对象(objects)，函数(function)，tags(struct,
    union, enumerations)，结构体和联合体成员\...

- 标识符不能任意起名，存在起名规则

### [对象(object)](https://en.cppreference.com/w/cpp/language/object)

- 在C中对象是一块内存空间，这个空间存放了值(value)；
- 每个对象都有相应的属性：size, storage duration, lifetime, value, identifier(i.e.id optional)；
- 对象或者引用（需非类属性）是 `变量(variable)`

.. attention:: 以下实体(entities)不是对象：值(value)，引用(reference)，函数(function)，参数包(parameter pack)

### [实体(entiry)](https://en.cppreference.com/w/cpp/language/basic_concepts)

- c++程序中的实体包括值(value)，对象(object)，引用(reference)，函数(function)，类型(type)，模板（template）\...

.. attention:: 预处理宏(prepocessor entity)不是c++实体（有人从它不是c++语法的内容去理解）

### override&&overload

override：虚函数的重写

overload：函数的重载（function overload, operator overload）

### 数据结构

数据结构是数据值、数据关系、作用于数据的函数和操作的集合

> a data structure is a collection of data values, the relationships among  them, and the functions or operations that can be applied to the data

### [表达式(expression)](https://en.cppreference.com/w/cpp/language/value_category)

- 包含字面值、变量名、操作数和操作符
- [expression evaluation](https://en.cppreference.com/w/cpp/language/eval_order)
- [full expression](http://eel.is/c++draft/intro.execution#def:full-expression)

#### [左值和右值的区别](https://en.cppreference.com/w/cpp/language/value_category)

- 每个c++表达式都可用 `value category`进行分类

- 左值和右值是从 `value category` 的角度来描述expression，而不是描述其value
- value category是编译器执行规则的基础，执行规则涉及：创建、拷贝和移动临时对象
- (C++17) `泛左值`：其evaluation决定了对象、位域、函数的ID(object, bit-field, or function)；`纯右值`：其evaluation能对一个对象、位域进行初始化，或者得到一个操作数的值；`亡值`：是一个泛左值，且能够标识对象或者位域是可以reused的或者说它接近生存周期

- 左值存在程序可访问的地址（可以使用取地址符）。
- 纯右值没有地址

### 类型分类

types可以按某种分类，分成如下几种：objects type, scalar types, trivial types, literal type, POD type...（但并不是泾渭分明的，比如int是scalar type也是literal type）

![image-20210928205058385](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210928205058385.png)

- 实测bool, char型是scalar type, void不是scalar type
