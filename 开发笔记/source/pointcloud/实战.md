# pcl-practice

## 将强度转为RGB

基于强度信息进行[分段线性拉伸](https://blog.csdn.net/huqiang_823/article/details/81054507)得到RGB，增强点云间的对比度，提高可视化效果，具体代码可看[实例](https://github.com/Livox-SDK/livox_horizon_loam/blob/master/src/laserMapping.cpp#L168)

```c++
void RGBpointAssociateToMap(PointType const *const pi,
                            pcl::PointXYZRGB *const po) {
  Eigen::Vector3d point_curr(pi->x, pi->y, pi->z);
  Eigen::Vector3d point_w = q_w_curr * point_curr + t_w_curr;
  po->x = point_w.x();
  po->y = point_w.y();
  po->z = point_w.z();
  int reflection_map = pi->curvature * 10;
  if (reflection_map < 30) {
    int green = (reflection_map * 255 / 30);
    po->r = 0;
    po->g = green & 0xff;
    po->b = 0xff;
  } else if (reflection_map < 90) {
    int blue = (((90 - reflection_map) * 255) / 60);
    po->r = 0x0;
    po->g = 0xff;
    po->b = blue & 0xff;
  } else if (reflection_map < 150) {
    int red = ((reflection_map - 90) * 255 / 60);
    po->r = red & 0xff;
    po->g = 0xff;
    po->b = 0x0;
  } else {
    int green = (((255 - reflection_map) * 255) / (255 - 150));
    po->r = 0xff;
    po->g = green & 0xff;
    po->b = 0;
  }
}
```

### rviz

```python
def bgr_to_hex(color_np):
    """
    Args:
        color_np:{n,3} [b,g,r]
        b = color_np[:, 0]
        g = color_np[:, 1]
        r = color_np[:, 2]
    """
    
    rgb_arr = np.array((color_np[:, 2] << 16) | (color_np[:, 1] << 8) | \
                       (color_np[:, 0] << 0), dtype=np.uint32)
    # 实测上只能用这种方式修改，不能使用astype转换
    rgb_arr.dtype = np.float32
    return rgb_arr
```

## PCL点云库实战

## 点云读写

### [写点云](https://pcl.readthedocs.io/projects/tutorials/en/latest/writing_pcd.html#writing-pcd)

![image-20211022000542975](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20211022000542975.png)

- 旧式接口

```c++
// 以下均为以前的API，现已统一用savePCDFile来替代
pcl::io::savePCDFileASCII("file.pcd", cloud);
pcl::io::savePCDFileBinary("file.pcd", cloud);
pcl::io::savePCDFileBinaryCompressed("file.pcd",cloud);
```

### [读点云](https://pcl.readthedocs.io/projects/tutorials/en/latest/reading_pcd.html#reading-pcd)

```c++
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
if (pcl::io::loadPCDFile<pcl::PointXYZ>("file.pcd", *cloud) == -1) {
    PCL_ERROR("Couldn't read file test_pcd.pcd \n");
    return (-1);
}
```

## [使用KD树](https://pcl.readthedocs.io/projects/tutorials/en/latest/kdtree_search.html#kdtree-search)

```c++
#include <pcl/point_cloud.h>
#include <pcl/kdtree/kdtree_flann.h>

// 建树
pcl::KdTreeFLANN<pcl::PointXYZ> kdtree;
kdtree.setInputCloud(cloud);

// 构建搜索点
pcl::PointXYZ searchPoint;
searchPoint.x = 1024.0f * rand () / (RAND_MAX + 1.0f);
searchPoint.y = 1024.0f * rand () / (RAND_MAX + 1.0f);
searchPoint.z = 1024.0f * rand () / (RAND_MAX + 1.0f);

// K nearest neighbor search
int K = 10;
std::vector<int> pointIdxNKNSearch(K);  // 该向量有大小
std::vector<float> pointNKNSquaredDistance(K);

if (kdtree.nearestKSearch(searchPoint, K, pointIdxNKNSearch, pointNKNSquaredDistance) > 0)
// todo

std::vector<int> pointIdxRadiusSearch;
std::vector<float> pointRadiusSquaredDistance;
// 含半径约束的搜索
if (kdtree.radiusSearch(searchPoint, radius, pointIdxRadiusSearch, pointRadiusSquaredDistance) > 0)
```

## 下采样

```cpp
typedef pcl::PointXYZI PointType;
// 进行下采样
pcl::PointCloud<PointType>::Ptr cloud_filtered(new pcl::PointCloud<PointType>);
pcl::VoxelGrid<PointType> vg;
vg.setInputCloud(cloud);
vg.setLeafSize(0.01f, 0.01f, 0.01f);
vg.filter(*cloud_filtered);
```

## [各种代码块](https://segmentfault.com/a/1190000007125502)

### 如果知道需要保存点的索引，如何从原点云中拷贝点到新点云？

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20211021100155700.png" alt="image-20211021100155700" style="zoom:67%;" />

### [PCL中pcl::PointCloud::Ptr 和Pcl::PointCloud两个类的相互转换](https://blog.csdn.net/h287850870/article/details/80988552)

```c++
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ> cloud;
cloud = *cloud_ptr;
cloud_ptr = cloud.makeShared;
```

### 创建PointCloud::Ptr对象

```c++
// pcl::PointCloud<pcl::PointXYZI>::Ptr pc_ptr_ = nullptr // 创建时初始化非用nullptr
pcl::PointCloud<pcl::PointXYZI>::Ptr pc_ptr_(new pcl::PointCloud<pcl::PointXYZI>);
```

## 提取点云子集

一般调用pcl的分割算法后，返回的是相关的索引。因此需要根据索引去进一步提取感兴趣的点云。

```c++
#include <pcl/filters/extract_indices.h>
pcl::PointCloud<pcl::PointXYZ>::Ptr input(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr output(new pcl::PointCloud<pcl::PointXYZ>);
// Create the filtering object
pcl::ExtractIndices<pcl::PointXYZ> extract;
// Extract the inliers
extract.setInputCloud(input);
// 点云索引
extract.setIndices(index_ptr);
// true：反相提取点云
extract.setNegative(false);
extract.filter(*output);
```

## 分割

.. attention:: 使用不规范的点云或会影响分割结果（尝试了用open3d导出的pcd文件，将其colors字段改为intensity）

## ros与pcl

### ros和pcl点云的相互转换

```c++
pcl::PointCloud<pcl::PointXYZRGB> colored_pointcloud;
sensor_msgs::PointCloud2 output_msg;
pcl::toROSMsg(colored_pointcloud, output_msg);
output_msg.header = input.header;
instance_pointcloud_pub_.publish(output_msg);
```

### [对ros点云进行TF变换](http://docs.ros.org/en/indigo/api/pcl_ros/html/namespacepcl__ros.html#a34090d5c8739e1a31749ccf0fd807f91)

- ros点云 + eigen tf

```c++
sensor_msgs::PointCloud2 pointcloud_with_z_offset;
// 1*3 -> 3*3 -> 4*4
Eigen::Affine3f z_up_translation(Eigen::Translation3f(0, 0, z_offset));
Eigen::Matrix4f z_up_transform = z_up_translation.matrix();
pcl_ros::transformPointCloud(z_up_transform, transformed_cloud,
transformed_cloud);
```

- ros点云 + ros TF + eigen tf

```c++
try
{
 geometry_msgs::TransformStamped transform_stamped;
 transform_stamped =
 tf_buffer_.lookupTransform(target_frame_, input.header.frame_id, input.header.stamp, ros::Duration(0.5));
 Eigen::Matrix4f affine_matrix = tf2::transformToEigen(transform_stamped.transform).matrix().cast<float>();
 pcl_ros::transformPointCloud(affine_matrix, input, transformed_cloud);
 transformed_cloud.header.frame_id = target_frame_;
}
catch (tf2::TransformException& ex)
{
 ROS_WARN("%s", ex.what());
 return false;
}
```

## 常用typedef

```c++
typedef pcl::PointXYZI PointType;
PointType nanPoint;
```

## 知识点

### 反射强度与材料的关系

from rslidar16 docs

- 黑色介质+漫反射（反射强度约等于0）
- 白色介质+漫反射（反射强度小于100）
- 半反透介质+镜面反射（反射强度大于100）
- 全反射（反射强度255）

### rviz color

![image-20210911215651517](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210911215651517.png)

## 参考资料

[pcl official wiki](https://pcl.readthedocs.io/projects/tutorials/en/latest/)

## 拓展工具

### CloudCompare

#### [安装](http://www.cloudcompare.org/)

```bash
# 方法一：可以直接使用apt安装，但是不支持pcd点云文件的导入
$ sudo apt install cloudcompare
# 方法二：使用snap安装，但是需要更换到edge版本
$ sudo snap install cloudcompare
$ sudo snap refresh --edge cloudcompare
```

#### 实战

- [官方实例教程](http://www.cloudcompare.org/tutorials.html)：包括剔除点云（仅支持2D裁剪）、配准（自动配准、交互式配准：自己选配置点）

- [为什么cloudcompare没有撤销操作](http://www.danielgm.net/cc/forum/viewtopic.php?t=1257)
- [CloudCompare支持的文件格式](https://www.cloudcompare.org/doc/wiki/index.php?title=FILE_I/O)
