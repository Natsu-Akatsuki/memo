# 01. 内置库实战

## os

### 设置环境变量

```python
import os

# 设置环境变量
os.environ["..."] = "value"
# 获取环境变量
os.getenv("环境变量名")
```

## signal

```python
def handle_int(sig, frame):
    """
    自定义信号回调函数
    Returns:

    """
    print("get signal: %s, I will quit" % sig)
    sys.exit(0)

if __name__ == '__main__':
    signal.signal(2, handle_int)
```

## [multiprocessing](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing)

* Cpython不是线程安全的 ，因此需要使用GIL；GIL即一个`互斥` (mutex)：能确保解释器一次只能执行某个线程的python字节码

### 进程的若干种状态

* 进程start时，状态为initial

* 进程start后，状态为started

* 执行完run的内容后，状态为stopped，含退出码(exit code)

#### python多进程中定义信号处理函数、自定义进程类

```python
class RosLaunchProc(Process):
    def __init__(self, args):
        """创建一个进程来启动roslaunch文件"""
        super().__init__()
        self.launch_proc = None
        self.roslaunch_files = args[0]
        self.is_core = args[1]

    def shutdown_handle(self, sig, frame):
        """
        自定义信号回调函数调用shutdown，调用后将disable spin，使进程terminate
        """
        self.launch_proc.shutdown()
        rospy.loginfo(f"\033[1;31m成功调用launch.shutdown()\033[0m")

    def run(self):
        # 信号函数的register需要放在run（i.e.主线程）
        signal.signal(signal.SIGUSR1, self.shutdown_handle)
        self.launch_proc = self.roslaunch_api()
        self.launch_proc.start()
        # 阻塞，防止进程stop状态
        rospy.spin()

    def roslaunch_api(self):
        uuid = roslaunch.rlutil.get_or_generate_uuid(options_runid=None, options_wait_for_master=False)
        roslaunch.configure_logging(uuid)
        return roslaunch.parent.ROSLaunchParent(uuid, self.roslaunch_files, self.is_core)
```

#### 关闭进程

```python
# 释放进程对象和与之相关的资源，在close前应该terminate()关闭该进程/或该进程已经stopped
<process_obj>.terminate()
<process_obj>.close()
```

#### 将某个函数放到新进程执行

```python
import time
from multiprocessing import Process
import os

def f():
    print(f'subProcess: {os.getpid()}')

if __name__ == '__main__':
    p = Process(target=f)
    p.start()
    time.sleep(1)
    print(f'fatherProcess: {os.getpid()}')
```

## [struct](https://docs.python.org/3/library/struct.html)

将python value转为C struct(在python中struct为`bytes object`)

### 返回一个字节对象

struck.pack(\<format>,value...)

```python
>>> from struct import *
# 返回一个C结构体(用字节对象来表征)
>>> pack('hhl', 1, 2, 3)
b'\x00\x01\x00\x02\x00\x00\x00\x03'
>>> unpack('hhl', b'\x00\x01\x00\x02\x00\x00\x00\x03')
(1, 2, 3)
>>> calcsize('hhl')
8
```

https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals



