
01. 内置库实战
==============

os
--

设置环境变量
^^^^^^^^^^^^

.. code-block:: python

   import os

   # 设置环境变量
   os.environ["..."] = "value"
   # 获取环境变量
   os.getenv("环境变量名")

signal
------

.. code-block:: python

   def handle_int(sig, frame):
       """
       自定义信号回调函数
       Returns:

       """
       print("get signal: %s, I will quit" % sig)
       sys.exit(0)

   if __name__ == '__main__':
       signal.signal(2, handle_int)

`multiprocessing <https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing>`_
------------------------------------------------------------------------------------------------------


* Cpython不是线程安全的 ，因此需要使用GIL；GIL即一个\ ``互斥`` (mutex)：能确保解释器一次只能执行某个线程的python字节码

进程的若干种状态
^^^^^^^^^^^^^^^^


* 
  进程start时，状态为initial

* 
  进程start后，状态为started

* 
  执行完run的内容后，状态为stopped，含退出码(exit code)

python多进程中定义信号处理函数、自定义进程类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

   class RosLaunchProc(Process):
       def __init__(self, args):
           """创建一个进程来启动roslaunch文件"""
           super().__init__()
           self.launch_proc = None
           self.roslaunch_files = args[0]
           self.is_core = args[1]

       def shutdown_handle(self, sig, frame):
           """
           自定义信号回调函数调用shutdown，调用后将disable spin，使进程terminate
           """
           self.launch_proc.shutdown()
           rospy.loginfo(f"\033[1;31m成功调用launch.shutdown()\033[0m")

       def run(self):
           # 信号函数的register需要放在run（i.e.主线程）
           signal.signal(signal.SIGUSR1, self.shutdown_handle)
           self.launch_proc = self.roslaunch_api()
           self.launch_proc.start()
           # 阻塞，防止进程stop状态
           rospy.spin()

       def roslaunch_api(self):
           uuid = roslaunch.rlutil.get_or_generate_uuid(options_runid=None, options_wait_for_master=False)
           roslaunch.configure_logging(uuid)
           return roslaunch.parent.ROSLaunchParent(uuid, self.roslaunch_files, self.is_core)

关闭进程
~~~~~~~~

.. code-block:: python

   # 释放进程对象和与之相关的资源，在close前应该terminate()关闭该进程/或该进程已经stopped
   <process_obj>.terminate()
   <process_obj>.close()

将某个函数放到新进程执行
~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

   import time
   from multiprocessing import Process
   import os

   def f():
       print(f'subProcess: {os.getpid()}')

   if __name__ == '__main__':
       p = Process(target=f)
       p.start()
       time.sleep(1)
       print(f'fatherProcess: {os.getpid()}')
