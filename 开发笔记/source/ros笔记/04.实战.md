

# 04.实战

## 1. [基于ros环境导入某个package下的python包](https://roboticsbackend.com/ros-import-python-module-from-another-package/)

### 简例

步骤一：创建python模板，相应的目录树如下

```plain
└── directory_name    		  # 一般可以设置为package_name
    ├── CMakeLists.txt
    ├── package.xml
    ├── setup.py
    └── src
        └── module_name   	  # 一般设置为module_name
            ├── import_me_if_you_can.py
            └── __init__.py
```

步骤二：编写`setup.py`文件

```python
## ! DO NOT MANUALLY INVOKE THIS setup.py, USE CATKIN INSTEAD

from distutils.core import setup
from catkin_pkg.python_setup import generate_distutils_setup

# fetch values from package.xml
setup_args = generate_distutils_setup(
    packages=['module_name'],
    package_dir={'': 'src'},
    requires=['rospy']
)

setup(**setup_args)
```

步骤三：编写`CMakeLists.txt` 文件

```cmake
cmake_minimum_required(VERSION 3.13)
project(project_name)
find_package(catkin REQUIRED COMPONENTS rospy)
# 调用当前CMakeLists文件所在目录下的setup.py
catkin_python_setup()   
catkin_package()			   
```

## 2.构建元包

### 参考教程

- 方案一：[answer.ros.org](https://answers.ros.org/question/322340/creating-metapackage/)

```bash
$ catkin_create_pkg <MY_META_PACKAGE> --meta
```

- 方案二：[ros-wiki教程](http://wiki.ros.org/catkin/package.xml#Metapackages)

直接添加一些细节到`CMakeLists`和`package.xml`上

## 3.使用nodelet

ros节点的通信是进程的通信，采用ros tcp的方法。当节点间传输的数据体量较大，通信（比如要反序列和序列化）的开销将比较大。因此若**希望减少节点间通讯的开销来提高实时性**，这就需要用到nodelet技术。具体例子，比如跑一些点云的预处理模块，涉及到采集的点云转换成ros数据，点云滤波去离群点，点云裁剪，点云去地面等节点，这些节点允许放在一个进程作为单独的线程去跑（`ros nodelet`程序能将一个`node` 进程节点转换为`nodelet`线程节点），然后想提高实时性就可以用到。总体给人一种将进程通信转换为线程通信的感觉。

### [显示当前系统的nodelet和其描述文件](http://wiki.ros.org/nodelet#Helper_tools)

```bash
$ rospack plugins --attrib=plugin nodelet   # 显示.xml文件
$ rosrun nodelet declared_nodelets          # 显示ros工作空间中已有的nodelet
```

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210810223516109.png" alt="image-20210810223516109" style="zoom:67%;" />

### plugin相关文档解析

nodelet与plugin密切相关，其中ros中的插件([plugin]([pluginlib](http://wiki.ros.org/pluginlib/Tutorials/Writing%20and%20Using%20a%20Simple%20Plugin)))即动态库中的可动态加载的类

![image-20210811003457276](https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210811003457276.png)

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210515175724200.png" alt="image-20210515175724200" style="zoom:67%;" />



### nodelet的启动

步骤一：一般而言，每个nodelet需要一个NodeletManager来管理，启动NodeletManager的方法

```bash
# 同时重命名NodeletManager
$ rosrun nodelet nodelet manager __name:=nodelet_manager 
```

等价于在launch文档中的：

``` xml
<node pkg="nodelet" type="nodelet" name="nodelet_manager" args="manager"/>
```

步骤二：加载nodelet到NodeletManager

```bash
# Launch a nodelet of type pkg/type(包名/xml文件中的class name) on manager manager
$ rosrun nodelet nodelet load nodelet_tutorial_math/Plus nodelet_manager
```

等价于在launch文档中的：

``` xml
<node pkg="nodelet" type="nodelet" name="Plus" args="load nodelet_tutorial_math/Plus nodelet_manager"/>
```

### nodelet launch文档解读

```xml
<!--都需要启动nodelet包的nodelet可执行文件，不过相应的启动参数不一样-->
<node pkg="nodelet" type="nodelet" name="euclidean_cluster_manager" args="manager" output="screen" />

<node pkg="nodelet" type="nodelet" name="$(anon voxel_grid_filter)" args="load pcl/VoxelGrid euclidean_cluster_manager" output="screen"> 
</node>

<node pkg="nodelet" type="nodelet" name="$(anon euclidean_cluster)" args="load euclidean_cluster/voxel_grid_based_euclidean_cluster_nodelet euclidean_cluster_manager" output="screen">
</node>

<!--standalone nodelet，不需要加载到nodelet manager，相关于启动一个普通node-->
<node pkg="nodelet" type="nodelet" name="Plus3" args="standalone nodelet_tutorial_math/Plus">
</node>
```

### 参考教程

- [ros.wiki官方教程](http://wiki.ros.org/nodelet)

需要对虚函数进行重载，所有有关ros的api需要在该部分进行初始化

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210810224100470.png" alt="image-20210810224100470" style="zoom:67%;" />

形如：

```c++
void EuclideanClusterNodelet::onInit()
{
  // Get the private node handle (provides this nodelets custom remappings in its private namespace)
  private_nh_ = getPrivateNodeHandle();

  private_nh_.param<std::string>("target_frame", target_frame_, "base_link");
  private_nh_.param<bool>("use_height", use_height_, false);
  private_nh_.param<int>("min_cluster_size", min_cluster_size_, 3);
  private_nh_.param<int>("max_cluster_size", max_cluster_size_, 200);
  private_nh_.param<float>("tolerance", tolerance_, 1.0);

  nh_ = getNodeHandle();
  pointcloud_sub_ =
    private_nh_.subscribe("input", 1, &EuclideanClusterNodelet::pointcloudCallback, this);

  cluster_pub_ =
    private_nh_.advertise<autoware_perception_msgs::DynamicObjectWithFeatureArray>("output", 10);
  debug_pub_ = private_nh_.advertise<sensor_msgs::PointCloud2>("debug/clusters", 1);
}
```

- [nodelet code template](https://www.clearpathrobotics.com/assets/guides/kinetic/ros/Nodelet%20Everything.html)

### ros自带的nodelet

```plain
...
pcl/PassThrough
pcl/VoxelGrid
pcl/ProjectInliers
pcl/ExtractIndices
pcl/StatisticalOutlierRemoval
pcl/RadiusOutlierRemoval
pcl/CropBox
pcl/NodeletMUX
pcl/NodeletDEMUX
pcl/PCDReader
pcl/BAGReader
...
```

## 4.[使用gdb调试launch中的节点](http://wiki.ros.org/roslaunch/Tutorials/Roslaunch%20Nodes%20in%20Valgrind%20or%20GDB)

核心为使用gdb -p

步骤一：修改`CmakeLists`的build type

```cmake
SET(CMAKE_BUILD_TYPE "Debug")
```

步骤二：gdb对应的进程

```bash
$ sudo gdb -p <pid_id>
```

## 5.ros API

### rosnode

* [官方文档 for python](http://docs.ros.org/en/hydro/api/rosnode/html/)

#### rosnode list

```python
# python
import rosnode
node_list = rosnode.get_node_names()
```

#### rosnode kill

```python
# python
node_list = rosnode.get_node_names()
_, _ = rosnode.kill_nodes(node_list)
```

### rostopic

#### rostopic list

```python
# python
import rospy
topic_list = rospy.get_published_topics()
```

### roslaunch

* [官方文档 for python](http://docs.ros.org/en/kinetic/api/roslaunch/html/index.html)，[官方文档 wiki with example](http://wiki.ros.org/roslaunch/API%20Usage)

- 该API支持中文路径

### rospack

* [官方文档 for python](http://docs.ros.org/en/independent/api/rospkg/html/python_api.html)

#### rospack find

```python
# python
# 获取某个package的绝对路径
from rospkg import RosPack
rp = RosPack()
path = rp.get_path('package_name')   # 返回某个包的绝对路径
```

---

```c++
// cpp
#include <ros/package.h>
std::string path = ros::package::getPath("package_name");
```

### [rviz(cpp)](http://docs.ros.org/en/jade/api/rviz/html/c++/classrviz_1_1VisualizationFrame.html#a76773514f60d7abbc5db8bd590acd79c)

## 6.ros命名空间

- cpp程序

```c++
// c++中描述的节点名不包含命名空间，无'/'(e.g即没有/.../...，只有...)
ros::init(argc, argv, "节点名"); 
```

- launch文件

```xml
<!-- launch中的节点名也不包含命名空间 -->
<node pkg="talker" type="talker" name="talker"/>
<!-- 可以通过group tag或ns attribute来添加命名空间 -->
<!-- 前者可同时给多个节点附上一个命名空间，后者则针对具体的一个，前者可被后者覆盖-->
<group ns="namespaceA">  
	<node ns='namespaceB' pkg="talker" type="talker" name="talker"/>
</group>
```

- topic
  - 当创建的节点有命名空间时，base类型(e.g. `node_name`，而非`/.../node_name`)的topic会附上节点的命名空间
  - 当创建的句柄带有(~)时，base类型的topic除了附上节点的命名空间，还会附上节点名作为命名空间

## 7.rosDebug

- 工具A：rqt（可查看相关的主题、节点等各种操作）

<img src="https://natsu-akatsuki.oss-cn-guangzhou.aliyuncs.com/img/image-20210902082605313.png" alt="image-20210902082605313" style="zoom:67%;" />

## 8.部署ros package

>  There is likely **a lot** more **learning curve** than catkin_make install + copy binaries. @[answers.ros](https://answers.ros.org/question/226581/deploying-a-catkin-package/)

[实战教程 github](https://github.com/GDUT-IIDCC/Sleipnir.PreCompile) 

---

**REMARK**

source的先后顺序非常重要

---

